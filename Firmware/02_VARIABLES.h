////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                 ВРЕМЕННЫЕ                 ///////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

float increment = 3.14 / 20;
float angle = 0;
int amplitude = 1000;
int y;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//              ОБЩИЕ НАСТРОЙКИ              ///////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uint8_t mode = 0;                            // Выбранный режим работы
uint8_t mode_last = 0;                       // Последний выбранный режим работы
bool mode_change = true;                     // Разрешение изменения режимов работы
bool meas_voltage = true;                    // Измерение напряжения
bool meas_amper = false;                     // Измерение тока
bool meas_resistance = false;                // Измерение сопротивления
bool meas_capacitance = false;               // Измерение емкости
bool meas_inductance = false;                // Измерение индуктивности
bool meas_oscillograph = false;              // Осциллограф
bool read_UART = false;                      // Чтение UART
bool plotter = false;                        // Плоттер
bool settings = false;                       // Настройки
bool light_pcb = false;                      // Подсветка платы
uint16_t delay_mode = 500;                   // Задержка для подписи режима
bool amper = false;                          // Положение реле по умолчанию
bool meny_draw = false;                      // Отображение названия пункта меню
uint64_t reg_b;                      // Отображение названия пункта меню
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                   БЛЮТУЗ                  ///////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
char *pin = "1234";                          // Пин код
String DEV_NAME = "QUARK";                   // Имя блютуз устройства
bool connectBL = false;                      // Состояние соединения
// ПРЕФФИКСЫ
String PREF_FIN = "FIN";                     // Префикс конца строки
// ВОЛЬТМЕТР
String PREF_VLT = "VLT";                     // Префикс вольтажа
// АМПЕРМЕТР
String PREF_AMP = "AMP";                     // Префикс ампер
String PREF_AAP = "AAP";                     // Префикс массива
// ОСЦИЛЛОГРАФ
String PREF_ARR = "ARR";                     // Префикс массива
String PREF_FRQ = "FRQ";                     // Префикс частоты
String PREF_SCL = "SCL";                     // Префикс масштаба
String PREF_OMX = "OMX";                     // Префикс максимума волны
String PREF_OMN = "OMN";                     // Префикс минимума волны


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                  БАТАРЕЯ                  ///////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
volatile uint8_t bat_counter = 0;            // Счетчик для проверки батареи
volatile bool bat_redraw = true;             // Перерисовка батареи
bool bat_redraw_chrg = true;                 // Перерисовка зарядки батареи
bool bat_red = true;                         // Красная батарея
uint8_t bat_counter_check = 600;             // Через сколько секунд проверить батарею /10
volatile uint8_t counter_seconds = 0;        // Секундный счетчик

bool check_bat = true;                       // Первый старт
uint16_t batt_level = 0;                     // Уровень заряда сырой
uint16_t batt_level_0 = 1700;                // Уровень заряда 1
uint16_t batt_level_1 = 1800;                // Уровень заряда 1
uint16_t batt_level_2 = 1900;                // Уровень заряда 1
uint16_t batt_level_3 = 2000;                // Уровень заряда 1
uint16_t batt_level_4 = 2100;                // Уровень заряда 1
uint16_t batt_level_5 = 2200;                // Уровень заряда 1

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                  КНОПКИ                   ///////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool btn_en = false;                         // Активация кнопок
bool btn_up = false;                         // Вверх
bool btn_dwn = false;                        // Вниз
bool btn_01_en = false;                      //
bool btn_02_en = false;                      //
bool btn_03_en = false;                      //
bool btn_04_en = false;                      //
bool btn_05_en = false;                      //

uint32_t count_mult = 100000;                // Частота таймера в микросекундах
uint8_t btn_press_delay = 5;                 // Задержка для определения нажатия
volatile uint8_t btn_counter = 0;            // Таймер кнопки
uint8_t btn_press_counter = 0;               // Количество нажатий
uint8_t btn_press_arr[6];                    // Массив для хранения последовательности нажатий

//НАСТРОЙКИ ЧУВСТВИТЕЛЬНОСТИ КНОПОК
#ifdef USB_POW
uint16_t btn_01_min = 20;
uint16_t btn_01_max = 60;
uint16_t btn_02_min = 300;
uint16_t btn_02_max = 400;
uint16_t btn_03_min = 150;
uint16_t btn_03_max = 250;
uint16_t btn_04_min = 3500;
uint16_t btn_04_max = 3600;
uint16_t btn_05_min = 3000;
uint16_t btn_05_max = 3100;
#else
#endif

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                 ВОЛЬТМЕТР                 ///////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
float voltage_prew;                          // Уровень напряжения на входе
float voltage_last;                          // Последнее значение напряжения на входе
uint16_t voltage_alarm = 24;                 // Уровень напряжения до опасного

float volt_level;                            // Минимальное значение вольт
float CMOS_5V_1 = 3.5;                       // Уровень логической единицы 5V
float CMOS_5V_0 = 1.5;                       // Уровень логического нуля 5V
float TTL_1 = 2.2;                           // Уровень логической единицы TTL
float TTL_0 = 0.6;                           // Уровень логического нуля TTL
float CMOS_18_1 = 1.35;                      // Уровень логической единицы 1.8V
float CMOS_18_0 = 0.63;                      // Уровень логического нуля 1.8V
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                 АМПЕРМЕТР                 ///////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool amper_count = true;                     // Разрешение перерисовки амперметра
float amper_prew;                            // Уровень тока на входе
float amper_last;                            // Последнее значение тока на входе
uint16_t amper_alarm = 3.0;                  // Уровень тока до опасного
float power;                                 // Значение мощности

uint16_t graph_width = 239;                  // Ширина графика
uint16_t amper_array_1[239];                 // Массив гравика
uint16_t amper_array_2[239];                 // Массив гравика сдвига
uint16_t amper_pos_time_1 = 40;              // Позиция первого числа
uint16_t amper_pos_time_2 = 140;             // Позиция второго числа
uint16_t amper_pos_time_3 = 240;             // Позиция третьего числа

uint8_t amper_pos_grid = 0;                  // Позиция сетки

uint16_t amper_time_1 = 0;                   // Время 1
uint16_t amper_time_2 = 0;                   // Время 2
uint16_t amper_time_3 = 0;                   // Время 3

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//               СОПРОТВИЛЕНИЕ               ///////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
float res_prew;                            // Уровень тока на входе
float res_last;                            // Последнее значение тока на входе

float res_array[24]
{ 1.0, 1.1, 1.2, 1.3, 1.5, 1.6, 1.8,         // Массив сопротивлений
  2.0, 2.2, 2.4, 2.7,
  3.0, 3.3, 3.6, 3.9,
  4.3, 4.7,
  5.1, 5.6,
  6.2, 6.8,
  7.5,
  8.2,
  9.1
};

uint8_t mult = 0;                            // Множитель
uint8_t num_01 = 0;                          // Первый знак
uint8_t num_02 = 0;                          // Второй знак
uint8_t num_03 = 0;                          // Третий знак
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                ОСЦИЛЛОГРАФ                ///////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uint16_t shift = 12288;                      // Сдвиг. ADC_3(IO39) - 12288  / ADC_5(IO33) - 20480
bool i2s_enable = false;                     // Запуск I2S
uint16_t osc_buffer_raw[BUFF_SIZE];          // Буффер сырых данных
uint16_t osc_buffer[BUFF_SIZE];              // Буффер данных
uint8_t num_rate = 2;                        // Номер диапазона по умолчанию
uint32_t mass_rate[] = {10000,               // Массив диапазонов
                        20000,
                        50000,
                        100000,
                        200000,
                        400000
                       };
bool auto_rate = true;                       // Автодиапазон
bool auto_scale = true;                      // Автомасштаб
float volt_level_min;                        // Минимальное значение вольт
float volt_level_max;                        // Максимальное значение вольт
float volt_level_min_last;                   // Последнее минимальное значение вольт
float volt_level_max_last;                   // Последнее максимальное значение вольт
uint8_t check_volt_num = 2;                  // Количество итераций для определения напряжения
uint8_t check_volt_cur = 0;                  // Текущая итерация
float check_v_min_mass[2];                   // Массив для хранения итераций минимального напряжения
float check_v_max_mass[2];                   // Массив для хранения итераций максимального напряжения

uint16_t triger_01 = 0;                      // Положение первого тригера в бфере
uint16_t triger_02 = 0;                      // Положение второго тригера в бфере
uint16_t triger_level = 0;                   // Значение для тригера
uint16_t triger_level_min;                   // Минимальное значение тригера
uint16_t triger_level_max;                   // Максимальное значение тригера

uint16_t duty = 0;                           // Период сырой
uint16_t duty_last = 0;                      // Период сырой последний
uint8_t duty_min = 50;                       // Период минимальная ширина на экране в пикселях
uint8_t duty_max = 80;                       // Период максимальная ширина на экране в пикселях
uint16_t period = 0;                         // Период вычисленный
uint32_t freq;                               // Частота вычисленная

uint8_t check_freq_num = 3;                  // Количество итераций для определения частоты
uint8_t check_freq_cur = 0;                  // Текущая итерация
uint32_t check_freq_mass[3];                 // Массив для хранения итераций

uint8_t osc_width = 210;                     // Ширина экрана
uint8_t osc_height = 95;                     // Высота экрана

uint8_t pos_y_max;                           // Высота маскимального уровня
uint8_t pos_y_min;                           // Высота минимального уровня
float curr_max;                              // Значение маскимального уровня
float curr_min;                              // Значение минимального уровня
bool BL_type;                                // Тип отправляемых данных

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                    UART                   ///////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uint32_t BAUD_RATE;                          // Скорость UART
bool baud_true = false;                      // Определена ли скорость 
bool baud_exit = false;                      // выход из режима
String incomming;                            // Входящее сообщение
bool end_mess;                               // Окончание передачи
String incoming_array[7];                    // Массив строк
uint8_t uart_arr = 0;                        // Текуущая итерация байта
uint16_t uart_buff = 1024;                   // Размер буфера
uart_event_t event;                          // Переменная события для UART
uint16_t baud_count;                         // Текущая попытка определить скорость
uint16_t baud_count_max = 500;               // Количество попыток определиь скорость
